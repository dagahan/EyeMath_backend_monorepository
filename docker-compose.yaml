name: eye-math


services:
  nginx:
    build:
      context: ./nginx
      dockerfile: dockerfile
    image: nginx
    container_name: nginx
    env_file: .env
    environment:
      RUNNING_INSIDE_DOCKER: 1
    ports:
      - "${NGINX_APP_PORT}:${NGINX_APP_PORT}"
    networks:
      - eye_math_network
    # depends_on:
    #   gateway:
    #     condition: service_healthy
    restart: ${DOCKER_CONTAINERS_RESTART}


  gateway:
    build:
      context: ./gateway
      dockerfile: dockerfile
    image: gateway
    container_name: gateway
    env_file: .env
    environment:
      RUNNING_INSIDE_DOCKER: 1
    ports:
      - "${GATEWAY_APP_PORT}:${GATEWAY_APP_PORT}"
    networks:
      - eye_math_network
    # healthcheck:
    #   test: 
    #     [
    #       "CMD", 
    #       "curl", 
    #       "-f", 
    #       "http://localhost:${GATEWAY_APP_PORT}/graphql", 
    #       "-H", 
    #       "Content-Type: application/json", 
    #       "--data-raw", 
    #       "{\"query\":\"{__typename}\"}"
    #     ]
    #   interval: 5s
    #   timeout: 5s
    #   retries: 20
    #   start_interval: 10s
    restart: ${DOCKER_CONTAINERS_RESTART}


  authorizer:
    build: 
      context: ./authorizer
      dockerfile: dockerfile
    image: authorizer
    container_name: authorizer
    env_file: .env
    environment:
      RUNNING_INSIDE_DOCKER: 1
    ports:
      - "${AUTHORIZER_APP_PORT}:${AUTHORIZER_APP_PORT}"
    networks:
      - eye_math_network
    depends_on:
      postgres:
        condition: service_healthy
    restart: ${DOCKER_CONTAINERS_RESTART}


# TODO: Recognizer is takes just too long time to download python dependensies, so it must be downloaded on image building stage in own dockerfile.
  recognizer:
    build: 
      context: ./recognizer
      dockerfile: dockerfile
    image: recognizer
    container_name: recognizer
    env_file: .env
    environment:
      RUNNING_INSIDE_DOCKER: 1
    ports:
      - "${RECOGNIZER_APP_PORT}:${RECOGNIZER_APP_PORT}"
    networks:
      - eye_math_network
    restart: ${DOCKER_CONTAINERS_RESTART}


  renderer:
    build: 
      context: ./renderer
      dockerfile: dockerfile
    image: renderer
    container_name: renderer
    env_file: .env
    environment:
      RUNNING_INSIDE_DOCKER: 1
    ports:
      - "${RENDERER_APP_PORT}:${RENDERER_APP_PORT}"
    networks:
      - eye_math_network
    restart: ${DOCKER_CONTAINERS_RESTART}


  solver:
    build:
      context: ./solver
      dockerfile: dockerfile
    image: solver
    container_name: solver
    env_file: .env
    environment:
      RUNNING_INSIDE_DOCKER: 1
    ports:
      - "${SOLVER_APP_PORT}:${SOLVER_APP_PORT}"
    networks:
      - eye_math_network
    restart: ${DOCKER_CONTAINERS_RESTART}

  
  postgres:
    build:
      context: ./postgres
      dockerfile: dockerfile
    image: postgres
    container_name: postgres
    env_file: .env
    environment:
      RUNNING_INSIDE_DOCKER: 1
    ports:
      - "${POSTGRES_APP_PORT}:${POSTGRES_APP_PORT}"
    networks:
      - eye_math_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 10
    volumes:
      - ./postgres/init-scripts:/docker-entrypoint-initdb.d
      - ./postgres-data:/var/lib/postgresql/data
    command: 
      - bash
      - -c
      - |
        SQL_CONTENT=$$(cat /docker-entrypoint-initdb.d/init-template.sql)
        SQL_PROCESSED=$$(echo "$$SQL_CONTENT" | envsubst)
        echo "$$SQL_PROCESSED" > /docker-entrypoint-initdb.d/init.sql
        echo "Generated init.sql:"
        cat /docker-entrypoint-initdb.d/init.sql
        exec docker-entrypoint.sh postgres
    restart: ${DOCKER_CONTAINERS_RESTART}

  # TODO: command for stating postgres must be placed in dockerfile, not in docker compose!


  # redis:
  #   image: redis:alpine
  #   ports:
  #     - "6379:6379"
  #   restart: on-failure


volumes:
  postgres_data:
    driver: local

networks:
  eye_math_network:
    driver: bridge
    name: eye_math_network